import os
import shutil

import pytest

from studio.app.common.core.mode import MODE
from studio.app.common.core.snakemake.smk import ForceRun, SmkParam
from studio.app.common.core.snakemake.smk_status_logger import SmkStatusLogger
from studio.app.common.core.snakemake.snakemake_executor import (
    delete_dependencies,
    snakemake_execute,
)
from studio.app.common.core.utils.pickle_handler import PickleReader
from studio.app.common.core.workflow.workflow import Edge, Node, NodeData
from studio.app.dir_path import DIRPATH

workspace_id = "default"
unique_id = "smk_exec_lccd"

node_1st_node_id = "lccd_cell_detection_1234"
node_2nd_node_id = "pca_1234"
node_1st_node_label = "lccd_cell_detection"
node_2nd_node_label = "pca"

smk_param = SmkParam(
    use_conda=True,
    cores=2,
    forceall=True,
    forcetargets=True,
    lock=False,
)

shutil.copytree(
    f"{DIRPATH.DATA_DIR}/output_test/{workspace_id}/{unique_id}",
    f"{DIRPATH.DATA_DIR}/output/{workspace_id}/{unique_id}",
    dirs_exist_ok=True,
)


nodeDict = {
    node_1st_node_id: Node(
        id=node_1st_node_id,
        type="a",
        data=NodeData(label=node_1st_node_label, param={}, path="", type=""),
        position={"x": 0, "y": 0},
        style={
            "border": None,
            "borderRadius": 0,
            "height": 100,
            "padding": 0,
            "width": 180,
        },
    ),
    node_2nd_node_id: Node(
        id=node_2nd_node_id,
        type="a",
        data=NodeData(label=node_2nd_node_label, param={}, path="", type=""),
        position={"x": 0, "y": 0},
        style={
            "border": None,
            "borderRadius": 0,
            "height": 100,
            "padding": 0,
            "width": 180,
        },
    ),
}


edgeDict = {
    "edge1": Edge(
        id="edge1",
        source="input_0",
        animated=False,
        sourceHandle="",
        style={},
        target=node_1st_node_id,
        targetHandle="",
        type={},
    ),
    "edge2": Edge(
        id="edge2",
        source=node_1st_node_id,
        animated=False,
        sourceHandle="",
        style={},
        target=node_2nd_node_id,
        targetHandle="",
        type={},
    ),
}

output_dirpath = f"{DIRPATH.OUTPUT_DIR}/{workspace_id}/{unique_id}"


@pytest.mark.lighter_processing
def test_snakemake_execute(client):
    """
    Test for Run snakemake
    """

    # Force running in standalone-mode
    MODE.reset_mode(is_standalone=True)

    # Run snakemake executor
    snakemake_execute(workspace_id, unique_id, smk_param)

    # Check snakemake execution results
    node_1st_pkl_path = f"{output_dirpath}/{node_1st_node_id}/{node_1st_node_label}.pkl"
    node_2nd_pkl_path = f"{output_dirpath}/{node_2nd_node_id}/{node_2nd_node_label}.pkl"
    assert os.path.exists(node_1st_pkl_path), "Workflow pickle not found"
    assert os.path.exists(node_2nd_pkl_path), "Workflow pickle not found"

    node_1st_pkl = PickleReader.read(node_1st_pkl_path)
    node_2nd_pkl = PickleReader.read(node_2nd_pkl_path)
    assert PickleReader.check_is_valid_node_pickle(
        node_1st_pkl
    ), "Invalid workflow pickle"
    assert PickleReader.check_is_valid_node_pickle(
        node_2nd_pkl
    ), "Invalid workflow pickle"

    # Check for generated snakemake_status_logger log file
    error_log_filepath = f"{output_dirpath}/{SmkStatusLogger.ERROR_LOG_NAME}"
    assert os.path.exists(error_log_filepath)


@pytest.mark.lighter_processing
def test_snakemake_delete_dependencies():
    """
    Test for delete snakemake dependencies
    """

    node_1st_pkl_path = f"{output_dirpath}/{node_1st_node_id}/{node_1st_node_label}.pkl"
    node_2nd_pkl_path = f"{output_dirpath}/{node_2nd_node_id}/{node_2nd_node_label}.pkl"

    # Existence check of dependencies files
    # *Files are pre-generated by `test_snakemake_execute`
    assert os.path.exists(node_1st_pkl_path), "Dependencies files not found"
    assert os.path.exists(node_2nd_pkl_path), "Dependencies files not found"

    # Run delete_dependencies
    smk_param.forcerun = [
        ForceRun(
            nodeId=node_1st_node_id,
            name=node_1st_node_label,
        ),
        ForceRun(
            nodeId=node_2nd_node_id,
            name=node_2nd_node_label,
        ),
    ]
    delete_dependencies(
        workspace_id=workspace_id,
        unique_id=unique_id,
        smk_params=smk_param,
        nodeDict=nodeDict,
        edgeDict=edgeDict,
    )

    # Check for deleted dependencies files
    assert not os.path.exists(node_1st_pkl_path), "Dependencies files remain"
    assert not os.path.exists(node_2nd_pkl_path), "Dependencies files remain"
